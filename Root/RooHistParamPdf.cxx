/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "Hzzws/RooHistParamPdf.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 
#include <iostream>

using namespace std;

ClassImp(RooHistParamPdf) 

 RooHistParamPdf::RooHistParamPdf(const char *name, const char *title, 
         RooAbsReal& _x,
         RooAbsReal& _kappa,
          const TH1& h_sig,
          const TH1& h_HB,
          const TH1& h_hH,
          const TH1& h_B
         ) :
     RooAbsPdf(name,title), 
     x("x","x",this,_x),
     kappa(" kappa"," kappa",this,_kappa)
 { 
     _arrSize = h_sig.GetNbinsX();
     _bins = new Double_t[_arrSize];
     _w_sig = new Double_t[_arrSize];
     _w_int_HB = new Double_t[_arrSize];
     _w_int_hH = new Double_t[_arrSize];
     _w_Bonly = new Double_t[_arrSize];

     for(Int_t ibin = 0; ibin < _arrSize; ibin++){
         _bins[ibin] = h_sig.GetBinLowEdge(ibin+1);
         _w_sig[ibin] = h_sig.GetBinContent(ibin+1);
         _w_int_HB[ibin] = h_HB.GetBinContent(ibin+1);
         _w_int_hH[ibin] = h_hH.GetBinContent(ibin+1);
         _w_Bonly[ibin] = h_B.GetBinContent(ibin+1);
     }
     // _bins[_arrSize] = h_sig.GetBinLowEdge(_arrSize+1);
     cout << "Number of array: " << _arrSize << endl;
 } 


 RooHistParamPdf::RooHistParamPdf(const RooHistParamPdf& other, const char* name) :  
     RooAbsPdf(other,name), 
     x("x",this,other.x),
     kappa("kappa",this,other.kappa),
     _arrSize(other._arrSize)
 { 
     _bins = new Double_t[_arrSize];
     _w_sig = new Double_t[_arrSize];
     _w_int_HB = new Double_t[_arrSize];
     _w_int_hH = new Double_t[_arrSize];
     _w_Bonly = new Double_t[_arrSize];

     for(Int_t ibin = 0; ibin < _arrSize; ibin++){
         _bins[ibin] = other._bins[ibin];
         _w_sig[ibin] = other._w_sig[ibin];
         _w_int_HB[ibin] = other._w_int_HB[ibin];
         _w_int_hH[ibin] = other._w_int_hH[ibin];
         _w_Bonly[ibin] = other._w_Bonly[ibin];
     }
     // _bins[_arrSize] = other._bins[_arrSize];
 } 

RooHistParamPdf::~RooHistParamPdf(){
    if(_bins) delete[] _bins;
    if(_w_sig) delete[] _w_sig;
    if(_w_int_HB) delete[] _w_int_HB;
    if(_w_int_hH) delete[] _w_int_hH;
}


 Double_t RooHistParamPdf::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
   Int_t bin = find_bin();
   if (bin >= _arrSize || bin < 0) return 0;

   // Double_t res = kappa * _w_sig[bin] + TMath::Sqrt(kappa) * _w_int_HB[bin] + TMath::Sqrt(kappa) * _w_int_hH[bin] + _w_Bonly[bin];
   Double_t res = kappa * _w_sig[bin] + TMath::Sqrt(kappa) * _w_int_HB[bin] + TMath::Sqrt(kappa) * _w_int_hH[bin];
   // cout << "bin: " << bin << " " << res << endl;
   if (res < 0) return 0;
   return res;
 } 

Int_t RooHistParamPdf::find_bin() const
{
    if(! _bins) return -1;

    Int_t ibin = 0;
    while(ibin < _arrSize && _bins[ibin] <= x){
        ibin ++;
    }
    return ibin-1;
}
/***
Int_t RooHistParamPdf::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName) const 
{
    if (matchArgs(allVars,analVars,x)) return 1 ;
    return 0 ;
}

Double_t RooHistParamPdf::analyticalIntegral(Int_t code, const char* rangeName) const 
{
    assert(code==1) ;
    Double_t res = 0;
    for(Int_t bin = 0; bin < _arrSize; bin++){
         Double_t bin_val = kappa * _w_sig[bin] + TMath::Sqrt(kappa) * _w_int_HB[bin] + TMath::Sqrt(kappa) * _w_int_hH[bin];
         res += bin_val;
    }
    cout << "Integral: " << res << endl;
    return res;
}
**/
